default_buildSelectClause :: SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document;
default_buildSelectClause builderState options columns = 
    let
        isDistinct = isElemBy Sql.Distinct options;
        distinctOptionText = if (isDistinct) then text "DISTINCT" else emptyDoc;

        maybeTopNInfo :: Maybe (Int, Boolean, Boolean);
        maybeTopNInfo = 
            case (find isTopNOption options) of
            Nothing -> Nothing;
            Just topNOptionValue -> 
                case topNOptionValue of
                Sql.TopN {n, percent, withTies} -> Just (n, percent, withTies);
        -- TODO: there should be an easy way for the SQL builder to change how the TOP N text is generated.
        --       For example, Access doesn't seem to support the 'WITH TIES' option, so it should be omitted (or perhaps an error thrown).
        topNOptionText = 
            let
                nText = intToString (field1 (fromJust maybeTopNInfo));
                percent = field2 (fromJust maybeTopNInfo);
                withTies = field3 (fromJust maybeTopNInfo);

                optionalPercentText = if (percent) then " PERCENT" else "";
                optionalWithTies = if (withTies) then " WITH TIES" else "";
            in
                case maybeTopNInfo of
                Nothing -> empty;
                Just _ ->
                    text ("TOP " ++ nText ++ optionalPercentText ++ optionalWithTies);

                
        prefixText = spread [distinctOptionText, topNOptionText];

        columnText column = 
            let
                (columnExpr, columnAlias) = column;

                columnExprText  = expressionText2 builder builderState columnExpr;
                columnAliasText = if (isEmptyDocument columnAlias) then emptyDoc
                                  else text "AS " `plusplus` default_quoteIdentifier columnAlias;
            in
                spread [columnExprText, columnAliasText];

        columnTextVals = map columnText columns;
    in
        stack [prefixText, fillSeparatedList True "," columnTextVals];
        

private default_quoteIdentifier :: String -> Document;
private default_quoteIdentifier = quoteIdentifierHelper (\_ -> True);

quoteIdentifierHelper :: (String -> Boolean) -> String -> String -> String -> Document;
public quoteIdentifierHelper quotesNeededFn openQuote closeQuote txt =
    let
        separator = ".";
        namePieces = splitString separator txt;
        quotedPieces = map (\name -> if (quotesNeededFn name) then enclose openQuote closeQuote name else name) namePieces;
        newIdentifier = join separator quotedPieces;
    in
        text newIdentifier;
